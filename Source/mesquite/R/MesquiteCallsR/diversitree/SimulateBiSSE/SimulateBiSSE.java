/* Mesquite.R source code.  Copyright 2010 W. Maddison, H. Lapp & D. Maddison. Mesquite.R is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.This source code and its compiled class files are free and modifiable under the terms of GNU General Public License v. 2.  (http://www.gnu.org/licenses/old-licenses/gpl-2.0.html)*/package mesquite.R.MesquiteCallsR.diversitree.SimulateBiSSE;import org.rosuda.JRI.REXP;import mesquite.lib.*;import mesquite.R.MesquiteCallsR.lib.RLinker;import mesquite.categ.lib.*;import mesquite.diverse.lib.*;/** ======================================================================== */public class SimulateBiSSE extends TreeCharSimulate {	protected static double rateCharStateChange0 = 0.005; 	protected static double rateCharStateChange1 = 0.005; 	protected static double spnForState0 = 0.1;	protected static double spnForState1 = 0.1;	protected static double extForState0 = 0.05;	protected static double extForState1 = 0.05;	protected static double prior1AtRoot = 0.5; //TODO: have toggle to set what is used	protected boolean keepAllExtinct = false;	//IF BOOLEAN SET THEN increment spnForState0 up by 0.01 or some such each new tree	/*.................................................................................................................*/	public String getName() {		return "Simulate BiSSE Trees (diversitree: tree.bisse)";	}	/*.................................................................................................................*/	public String getVersion() {		return null;	}	/*.................................................................................................................*/	/** returns an explanation of what the module does.*/	public String getExplanation() {		return "(From diversitree package in R): Generates tree by a speciation/extinction model in which a character controls rates of speciation/extinction.  Time to next event drawn from negative exponential distribution." ;	}	RLinker rLinker;	RandomBetween rng;	/*.................................................................................................................*/	public boolean showCitation(){		return true;	}	/*.................................................................................................................*/	public boolean startJob(String arguments, Object condition, boolean hiredByName) {		rLinker = new RLinker();		if (!rLinker.linkToR()) {			return sorry(getName() + " cannot run: Problem with R.");		}		rng= new RandomBetween(1);		addMenuItem("Rate of Change of Character change from state 0 to 1...", makeCommand("setCRate0",  this));		addMenuItem("Rate of Change of Character change from state 1 to 0...", makeCommand("setCRate1", this));		addMenuItem("Rate of Speciation if state 0...", makeCommand("setSRate0",  this));		addMenuItem("Rate of Speciation if state 1...", makeCommand("setSRate1",  this));		addMenuItem("Rate of Extinction if state 0...", makeCommand("setERate0",  this));		addMenuItem("Rate of Extinction if state 1...", makeCommand("setERate1",  this));		//	addMenuItem("Desired Tree size",makeCommand("setTreeSize",this));		addMenuItem("Maximum Tree size to search", makeCommand("setCeilingSize",this));		//	addMenuItem("Save Extinct lineages", makeCommand("toggleKeepAllExtinct",this));		addMenuItem("Prior on state at root...", makeCommand("setPrior",  this));		return true;	}	public void endJob(){		if (rLinker != null){			rLinker.end();		}		super.endJob();	}	public boolean showDialog(Taxa taxa){		MesquiteInteger buttonPressed = new MesquiteInteger(1);		ExtensibleDialog dlog = new ExtensibleDialog(containerOfModule(), "Simulation Parameters",  buttonPressed);		dlog.defaultCancelLabel = null;		DoubleField[] value = new DoubleField[7];		//	IntegerField treeField;		IntegerField ceilingField;		//Checkbox keepExtinctBox;		value[0] = dlog.addDoubleField("Rate 0 -> 1: ", rateCharStateChange0, 6, 0, 100);		value[1] = dlog.addDoubleField("Rate 1 -> 0: ", rateCharStateChange1, 6, 0, 100);		value[2] = dlog.addDoubleField("Rate of Speciation with 0: ", spnForState0, 6, 0, 100);		value[3] = dlog.addDoubleField("Rate of Speciation with 1 :", spnForState1, 6, 0, 100);		value[4] = dlog.addDoubleField("Rate of Extinction with 0: ", extForState0, 6, 0, 100);		value[5] = dlog.addDoubleField("Rate of Extinction with 1: ", extForState1, 6, 0, 100);		value[6] = dlog.addDoubleField("Prior probability of state 1 at root (? = use stationary freq.): ", MesquiteDouble.unassigned, 6, 0, 1.0);		value[6].setPermitUnassigned(true);		//keepExtinctBox = dlog.addCheckBox("Keep Extinct Lineages", keepAllExtinct);		dlog.completeAndShowDialog(true);		boolean ok = (dlog.query()==0);		boolean success = false;		if (ok) {			success = true;			for (int i=0; i<6; i++)				if (!MesquiteDouble.isCombinable(value[i].getValue()))					success = false;			//	if (!MesquiteInteger.isCombinable(treeField.getValue()))			//		success = false;			if (!success){				dlog.dispose();				return false;			}			rateCharStateChange0 = value[0].getValue();			rateCharStateChange1 = value[1].getValue();			spnForState0 = value[2].getValue();			spnForState1 = value[3].getValue();			extForState0 = value[4].getValue();			extForState1 = value[5].getValue();			prior1AtRoot = value[6].getValue();			//	treeSize = treeField.getValue();			//	keepAllExtinct = keepExtinctBox.getState();		}		else {			dlog.dispose();   			return false;		}		dlog.dispose();   		return true;	}	/*.................................................................................................................*/	public double stationaryFreq0() {  		double d = spnForState0-spnForState1+extForState1-extForState0;		double q01 = rateCharStateChange0;		double q10 = rateCharStateChange1;		if (Math.abs(d ) < 1e-100){			if (q01 + q10 == 0)				return 0.5;			return q10/(q01+q10);		}		double part = d - q01 - q10;		part = part*part + 4*d*q10;		if (part >=0)			part = Math.sqrt(part);		else			return MesquiteDouble.unassigned;		double plus = (q01 + q10 - d + part) / (-2*d);		double minus = (q01 + q10 - d - part) / (-2*d);		if (minus < 0 || minus >1)			return plus;		else if (plus < 0 || plus >1)			return minus;		else			return MesquiteDouble.unassigned;	}	/*.................................................................................................................*/	/** returns whether this module is requesting to appear as a primary choice */	public boolean requestPrimaryChoice(){		return false;  	}	/*.................................................................................................................*/	public boolean isSubstantive(){		return true;	}	/*.................................................................................................................*/	public boolean isPrerelease(){		return false;	}	/*.................................................................................................................*/	public Snapshot getSnapshot(MesquiteFile file) {		Snapshot temp = new Snapshot();		temp.addLine("setCRate0 " + rateCharStateChange0);		temp.addLine("setCRate1 " + rateCharStateChange1);		temp.addLine("setSRate0 " + spnForState0);		temp.addLine("setSRate1 " + spnForState1);		temp.addLine("setERate0 " + extForState0);		temp.addLine("setERate1 " + extForState1);		temp.addLine("setPrior " + prior1AtRoot);		//temp.addLine("setTreeSize " + treeSize);		temp.addLine("toggleKeepAllExtinct " + MesquiteBoolean.toOffOnString(keepAllExtinct));		return temp;	}	MesquiteInteger pos = new MesquiteInteger(0);	/*.................................................................................................................*/	public Object doCommand(String commandName, String arguments, CommandChecker checker) {		if (checker.compare(this.getClass(), "Sets the rate of change of the categorical character", "[number]", commandName, "setCRate0")) {			pos.setValue(0);			double s = MesquiteDouble.fromString(arguments, pos);			if (!MesquiteDouble.isCombinable(s))				s = MesquiteDouble.queryDouble(containerOfModule(), "Rate", "Rate of Evolution of Speciation Controlling Character 0 -> 1", rateCharStateChange0);			if (MesquiteDouble.isCombinable(s)) {				rateCharStateChange0 = s;				prior1AtRoot =  1.0 - stationaryFreq0();				if (!MesquiteThread.isScripting())					parametersChanged();			}		}		else if (checker.compare(this.getClass(), "Sets the rate of change of the categorical character", "[number]", commandName, "setCRate1")) {			pos.setValue(0);			double s = MesquiteDouble.fromString(arguments, pos);			if (!MesquiteDouble.isCombinable(s))				s = MesquiteDouble.queryDouble(containerOfModule(), "Rate", "Rate of Evolution of Speciation Controlling Character 1 -> 0", rateCharStateChange1);			if (MesquiteDouble.isCombinable(s)) {				rateCharStateChange1 = s;				prior1AtRoot =  1.0 - stationaryFreq0();				if (!MesquiteThread.isScripting())					parametersChanged();			}		}		else if (checker.compare(this.getClass(), "Sets the rate of speciation if 0", "[number]", commandName, "setSRate0")) {			pos.setValue(0);			double s = MesquiteDouble.fromString(arguments, pos);			if (!MesquiteDouble.isCombinable(s))				s = MesquiteDouble.queryDouble(containerOfModule(), "Rate", "Rate of Speciation if 0", spnForState0);			if (MesquiteDouble.isCombinable(s)) {				spnForState0 = s;				prior1AtRoot =  1.0 - stationaryFreq0();				if (!MesquiteThread.isScripting())					parametersChanged();			}		}		else if (checker.compare(this.getClass(), "Sets the rate of speciation if 1", "[number]", commandName, "setSRate1")) {			pos.setValue(0);			double s = MesquiteDouble.fromString(arguments, pos);			if (!MesquiteDouble.isCombinable(s))				s = MesquiteDouble.queryDouble(containerOfModule(), "Rate", "Rate of Speciation if 1", spnForState1);			if (MesquiteDouble.isCombinable(s)) {				spnForState1 = s;				prior1AtRoot =  1.0 - stationaryFreq0();				if (!MesquiteThread.isScripting())					parametersChanged();			}		}		else if (checker.compare(this.getClass(), "Sets the rate of extinction if 0", "[number]", commandName, "setERate0")) {			pos.setValue(0);			double s = MesquiteDouble.fromString(arguments, pos);			if (!MesquiteDouble.isCombinable(s))				s = MesquiteDouble.queryDouble(containerOfModule(), "Rate", "Rate of Extinction if 0", extForState0);			if (MesquiteDouble.isCombinable(s)) {				extForState0 = s;				prior1AtRoot =  1.0 - stationaryFreq0();				if (!MesquiteThread.isScripting())					parametersChanged();			}		}		else if (checker.compare(this.getClass(), "Sets the rate of extinction if 1", "[number]", commandName, "setERate1")) {			pos.setValue(0);			double s = MesquiteDouble.fromString(arguments, pos);			if (!MesquiteDouble.isCombinable(s))				s = MesquiteDouble.queryDouble(containerOfModule(), "Rate", "Rate of Extinction if 1", extForState1);			if (MesquiteDouble.isCombinable(s)) {				extForState1 = s;				prior1AtRoot =  1.0 - stationaryFreq0();				if (!MesquiteThread.isScripting())					parametersChanged();			}		}		/*		else if (checker.compare(this.getClass(), "Sets desired tree size", "[number]", commandName, "setTreeSize")) {			pos.setValue(0);			int s = MesquiteInteger.fromString(arguments, pos);			if (!MesquiteDouble.isCombinable(s))				s = MesquiteInteger.queryInteger(containerOfModule(), "Root state", "Probability of state 1 at root", treeSize);			if (MesquiteInteger.isCombinable(s)) {				treeSize = s;				if (!MesquiteThread.isScripting())					parametersChanged();			}		}*/		else if (checker.compare(this.getClass(), "Sets the prior probability of state 1 at root", "[number]", commandName, "setPrior")) {			pos.setValue(0);			double s = MesquiteDouble.fromString(arguments, pos);			if (!MesquiteDouble.isCombinable(s))				s = MesquiteDouble.queryDouble(containerOfModule(), "Root state", "Probability of state 1 at root", prior1AtRoot);			if (MesquiteDouble.isCombinable(s)) {				prior1AtRoot = s;				if (!MesquiteThread.isScripting())					parametersChanged();			}		}		else if (checker.compare(this.getClass(), "Sets whether or not extinct lineages are preserved", "[on or off]", commandName, "toggleKeepAllExtinct")) {			if (StringUtil.blank(arguments))				keepAllExtinct = !keepAllExtinct;			else {				String s = ParseUtil.getFirstToken(arguments, pos);				if ("on".equalsIgnoreCase(s))					keepAllExtinct = true;				else if  ("off".equalsIgnoreCase(s))					keepAllExtinct = false;			}		}		else return  super.doCommand(commandName, arguments, checker);		return null;	}	/*.................................................................................................................*/	public String getDataType(){		return CategoricalData.DATATYPENAME;	}	protected MesquiteInteger countOfSpecies = new MesquiteInteger(0);	protected MesquiteDouble accumulator = new MesquiteDouble(0.0);	/*.................................................................................................................*/	public  void doSimulation(Taxa taxa, int replicateNumber, ObjectContainer treeContainer, ObjectContainer characterHistoryContainer, MesquiteLong seed){		if (!initialized)			initialize(taxa);		//save random seed used to make tree under tree.seed for use in recovering later		rng.setSeed(seed.getValue());		int rootState = 0;		if (rng.nextDouble() < prior1AtRoot)			rootState = 1;		if (rLinker ==  null)			return;	//	rLinker.setVerbose(true);		if (!rLinker.require("diversitree"))			return;		REXP bdtree = null;		REXP result = null;		int count = 0;		rLinker.eval("set.seed(" + seed.getValue() + ")");		//rLinker.eval("set.seed(" + (short)seed.getValue() + ")");		String options = "c(" + spnForState0 + ",  " + spnForState1  + ",  " + extForState0 + ",  " + extForState1 + ",  " + rateCharStateChange0 + ",  " + rateCharStateChange1+ ") ";		boolean report = false;		double[] states = null;		String[] labels = null;		while (result == null && count++<100){			bdtree = rLinker.eval("bdtree <- tree.bisse(" + options + ", max.taxa = " + taxa.getNumTaxa() + ", max.t=Inf, include.extinct = FALSE, x0 = " + rootState +")");			if (bdtree != null){				if (report){					rLinker.eval("print(bdtree)");					rLinker.eval("print(bdtree$tip.label)");					rLinker.eval("print(bdtree$tip.state)");					rLinker.eval("print(write.tree(bdtree, file = \"\", append= FALSE, digits = 10))");				}				rLinker.assign("my.names", rLinker.getTaxonLabelsVector(taxa));				rLinker.eval("my.names <- sample(my.names)");				rLinker.eval("bdtree$tip.label <- my.names");				rLinker.eval("bdtree$node.label <- NULL");				REXP tipLabels = rLinker.eval("bdtree$tip.label");				REXP tipStates = rLinker.eval("bdtree$tip.state");				states = (double[])tipStates.getContent();				labels = (String[])tipLabels.getContent();				rLinker.eval("class(bdtree)");				result = rLinker.eval("newick <- write.tree(bdtree, file = \"\", append= FALSE, digits = 10)");			}		}		if (result == null)			return;		String description = result.asString();		//	description = StringUtil.replace(description, "sp", "");		MesquiteTree t = new MesquiteTree(taxa, description);		CategoricalHistory charHistory = new CategoricalHistory(taxa, t.getNumNodeSpaces());		if (t != null && states != null)			harvestStates(t, t.getRoot(), charHistory, states, labels);		treeContainer.setObject(t);		characterHistoryContainer.setObject(charHistory);	}	void harvestStates(Tree tree, int node, CategoricalHistory charHistory, double[] states, String[] labels){		if (tree.nodeIsTerminal(node)){			int it = tree.taxonNumberOfNode(node);			if (it>=0){				String name = tree.getTaxa().getTaxonName(it);				int itS = StringArray.indexOf(labels, name);				if (itS >=0){					long state = CategoricalState.unassigned;					if (states[itS] > -0.001 && states[itS] < 0.001)						state = CategoricalState.makeSet(0);					else if (states[itS] > 0.999 && states[itS] < 1.001)						state = CategoricalState.makeSet(1);					charHistory.setState(node, state);				}			}		}		for (int d = tree.firstDaughterOfNode(node); tree.nodeExists(d); d = tree.nextSisterOfNode(d)) {			harvestStates(tree, d, charHistory, states, labels);		}	}	boolean initialized = false;	public void initialize(Taxa taxa){		initialized = true;		if (!MesquiteThread.isScripting()){			showDialog(taxa);		}		if (prior1AtRoot == MesquiteDouble.unassigned)			prior1AtRoot =  1.0 - stationaryFreq0();	}	/*.................................................................................................................*/	/*.................................................................................................................*/	public String getParameters() {		return "Rates: " + MesquiteDouble.toStringDigitsSpecified(rateCharStateChange0, 4) + "," + MesquiteDouble.toStringDigitsSpecified(rateCharStateChange1, 4) + "/" + MesquiteDouble.toStringDigitsSpecified(spnForState0, 4) + "," +MesquiteDouble.toStringDigitsSpecified(spnForState1, 4) + "/" +MesquiteDouble.toStringDigitsSpecified(extForState0, 4) + "," +MesquiteDouble.toStringDigitsSpecified(extForState1, 4);	}	/*.................................................................................................................*/}/*class SimOptions  {	public void queryOptions(MesquiteWindow window, MesquiteDouble lambda0, MesquiteDouble lambda1, MesquiteDouble mu0, MesquiteDouble mu1, MesquiteDouble q01, MesquiteDouble q10){		MesquiteInteger buttonPressed = new MesquiteInteger(1);		ExtensibleDialog dialog = new ExtensibleDialog(window, "BiSSE (diversitree)",buttonPressed);		dialog.addLargeOrSmallTextLabel("Options for diversitree's BiSSE Simulation");		//	if (queryDialog.isInWizard())		//		queryDialog.appendToHelpString("<h3>Initial guesses for alpha and sigma parameters</h3>Reasonable defaults might be 0 for alpha and 1 for sigma.");		DoubleField l0 = dialog.addDoubleField("lambda0", lambda0.getValue(), 20);		DoubleField l1 = dialog.addDoubleField("lambda1", lambda1.getValue(), 20);		DoubleField m0 = dialog.addDoubleField("mu0", mu0.getValue(), 20);		DoubleField m1 = dialog.addDoubleField("mu1", mu1.getValue(), 20);		DoubleField q0 = dialog.addDoubleField("q01", q01.getValue(), 20);		DoubleField q1 = dialog.addDoubleField("q10", q10.getValue(), 20);		dialog.completeAndShowDialog(true);		if (buttonPressed.getValue()==0) {			lambda0.setValue(l0.getValue());			lambda1.setValue(l1.getValue());			mu0.setValue(m0.getValue());			mu1.setValue(m1.getValue());			q01.setValue(q0.getValue());			q10.setValue(q1.getValue());		}		dialog.dispose();	}} */