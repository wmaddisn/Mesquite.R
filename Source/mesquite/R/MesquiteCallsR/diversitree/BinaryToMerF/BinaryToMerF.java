/* Mesquite.R source code.  Copyright 2010 W. Maddison, H. Lapp & D. Maddison. Mesquite.R is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.This source code and its compiled class files are free and modifiable under the terms of GNU General Public License v. 2.  (http://www.gnu.org/licenses/old-licenses/gpl-2.0.html)*/package mesquite.R.MesquiteCallsR.diversitree.BinaryToMerF; import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.lib.characters.CharacterData;import mesquite.lib.duties.*;import mesquite.lib.table.*;import mesquite.meristic.lib.*;import mesquite.categ.lib.*;/* ======================================================================== */public class BinaryToMerF extends MeristicDataAlterer {	CharacterSource charTask;	/*.................................................................................................................*/	public String getName() {		return "Binary to Freq. (for diversitree BiSSE Unresolved)";	}	/*.................................................................................................................*/	/** returns an explanation of what the module does.*/	public String getExplanation() {		return "Fills cells with the conversion of a binary character into a vector of frequencies, for use by diversitree's BiSSE for Terminally Unresolved Trees." ;	}/*.................................................................................................................*/	public boolean startJob(String arguments, Object condition, boolean hiredByName) {		charTask = (CharacterSource)hireNamedEmployee(CharacterSource.class, "#StoredCharacters", CategoricalState.class);		if (charTask == null)			return sorry(getName() + " can't be used because a source of characters was not found");		return true;	}	/*.................................................................................................................*/	public boolean isSubstantive(){		return true;	}	/*.................................................................................................................*/	public boolean isPrerelease(){		return false;	}	/*.................................................................................................................*/	/** returns whether this module is requesting to appear as a primary choice */	public boolean requestPrimaryChoice(){		return true;  	}	/*.................................................................................................................*/	/** Called to alter data in those cells selected in table*/	public void alterCell(CharacterData data, int ic, int it){	}	/*.................................................................................................................*/	/** Called to alter data in those cells selected in table*/	public boolean alterData(CharacterData data, MesquiteTable table,UndoReference undoReference){		if (!(data instanceof MeristicData))			return false;		MeristicData mData = (MeristicData)data;		int ic = charTask.queryUserChoose(data.getTaxa(), "for translation to frequencies for BiSSE (unresolved)");		if (!MesquiteInteger.isCombinable(ic))			return false;		CharacterDistribution dist = charTask.getCharacter(data.getTaxa(), ic);		if (dist == null || !(dist instanceof CategoricalDistribution))			return false;		mData.addCharacters(mData.getNumChars(), 1, false);		NameReference nrUnnamed = NameReference.getNameReference("unnamed");		NameReference nrZero = NameReference.getNameReference("state0");		NameReference nrOne = NameReference.getNameReference("state1");		NameReference nrUnknown = NameReference.getNameReference("stateUnknown");		NameReference nr0 = mData.getItemReference(0);		if (nr0 == null || nr0.getValue() == null  || nr0 == nrUnnamed)			mData.setItemReference(0, nrZero);		if (mData.getNumItems()>1){  //at least two items already			NameReference nr1 = mData.getItemReference(1);			if (nr1 == null || nr1.getValue() == null  ||nr1 == nrUnnamed)				mData.setItemReference(1, nrOne);						if (mData.getNumItems()>2){  //all three tiems already exist				NameReference nr2 = mData.getItemReference(2);				if (nr2 == null || nr2.getValue() == null  || nr2 == nrUnnamed)					mData.setItemReference(2, nrUnknown);			}			else {  //2 times already; need to make last item				mData.addItem(nrUnknown.getValue());			}		}		else {  //only 1 item; need to make last two items			mData.addItem(nrOne.getValue());			mData.addItem(nrUnknown.getValue());		}		ic = mData.getNumChars() -1;  //the character that will be made		CategoricalDistribution origDist = (CategoricalDistribution)dist;		for (int it = 0; it<mData.getNumTaxa(); it++){			long orig = origDist.getState(it);			// if uncertain or missing set to 0, 0, 1			if (CategoricalState.isUncertain(orig) || !CategoricalState.isCombinable(orig)){ //polymorphic 01				mData.setState(ic, it, 0, 0);				mData.setState(ic, it, 1, 0);				mData.setState(ic, it, 2, 1);			}			else {				// otherwise set to whichever 0, 1 the set has				if (CategoricalState.isElement(orig, 0))					mData.setState(ic, it, 0, 1);				else					mData.setState(ic, it, 0, 0);				if (CategoricalState.isElement(orig, 1))					mData.setState(ic, it, 1, 1);				else					mData.setState(ic, it, 1, 0);				//and add indication of unknown if others				if ((orig | 3L) != 3L)  // orig has things beyond 0, 1					mData.setState(ic, it, 2, 1);				else					mData.setState(ic, it, 2, 0);			}		}				return true;	}}