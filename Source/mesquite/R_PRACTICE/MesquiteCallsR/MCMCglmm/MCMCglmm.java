/* PDAP:PDTREE package for Mesquite  copyright 2001-2009 P. Midford & W. MaddisonPDAP:PDTREE is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.The web site for PDAP:PDTREE is http://mesquiteproject.org/pdap_mesquite/This source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.R_PRACTICE.MesquiteCallsR.MCMCglmm;/*~~  */import org.rosuda.JRI.REXP;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.R.MesquiteCallsR.lib.RLinker;import mesquite.R.common.APETree;import mesquite.categ.lib.CategoricalDistribution;import mesquite.categ.lib.CategoricalState;import mesquite.cont.lib.*;import mesquite.lib.duties.*;/** ======================================================================== *///Peter: this is a new module (see also NumForTreeWith2Chars in Basic).public class MCMCglmm extends NumberFor2CharAndTree {	public void getEmployeeNeeds(){  //This gets called on startup to harvest information; override this and inside, call registerEmployeeNeed	}	protected RLinker rLinker;	/*.................................................................................................................*/	public boolean startJob(String arguments, Object condition, boolean hiredByName) {		rLinker = new RLinker();		if (!rLinker.linkToR()) {			return sorry(getName() + " cannot run: Problem with R.");		}		return true; //false if no appropriate employees!	}	public boolean requestPrimaryChoice(){		return true;	}	/*.................................................................................................................*/	/** Called to provoke any necessary initialization.  This helps prevent the module's intialization queries to the user from   	happening at inopportune times (e.g., while a long chart calculation is in mid-progress)*/	public void initialize(Tree tree, CharacterDistribution charStatesX, CharacterDistribution charStatesY){	}	/*.................................................................................................................*/	/*in future this will farm out the calculation to the modules that deal with appropriate character model*/	public  void calculateNumber(Tree aTree, CharacterDistribution charStatesX, CharacterDistribution charStatesY, MesquiteNumber result, MesquiteString resultString) {  		if (result==null)			return;		clearResultAndLastResult(result);		if (resultString!=null)			resultString.setValue("MCMCglmm was not able to return a result.");		if (aTree==null || charStatesX ==null || charStatesY ==null) {			if (resultString!=null)				resultString.setValue("MCMCglmm can't be used because tree or characters not supplied");			return;		}		else {			if (!rLinker.require("MCMCglmm"))				return;			if (!rLinker.require("geiger"))				return;			rLinker.setEchoRConsole(true);			rLinker.setEchoMesquiteRCalls(true);						MesquiteTree tree = (MesquiteTree)aTree;			APETree apeTree = new APETree(tree);			rLinker.sendTreeToR(apeTree, "tree");			if (charStatesX instanceof ContinuousDistribution && charStatesY instanceof CategoricalDistribution){				Debugg.println("CONTINUOUS PREDICTOR, CATEGORICAL RESPONSE");				ContinuousDistribution indepX = (ContinuousDistribution)charStatesX;				CategoricalDistribution depY = (CategoricalDistribution)charStatesY;				int numTerminals = tree.numberOfTerminalsInClade(tree.getRoot());				int[] dependentValues = new int[numTerminals];				String[] rowNames = new String[numTerminals];				for (int i = 0; i< numTerminals; i++){					dependentValues[i] = CategoricalState.minimum(depY.getState(apeTree.getMesquiteTaxon(i+1)));					rowNames[i] = tree.getTaxa().getTaxonName(apeTree.getMesquiteTaxon(i+1));				}				double[] independentValues = new double[numTerminals];				for (int i = 0; i< numTerminals; i++){					independentValues[i] = indepX.getState(apeTree.getMesquiteTaxon(i+1));				}																												rLinker.assign("data",dependentValues);				rLinker.eval("dim(data) <- c(" + numTerminals + ",1)");				rLinker.assign("rowNames",rowNames);				rLinker.eval("rownames(data) <- rowNames");				rLinker.eval("data <- as.data.frame(data)");  //turning into a data frame				rLinker.assign("secondColumn",independentValues);				rLinker.eval("data <- cbind(data, secondColumn)");				rLinker.eval("colnames(data)[1] <- 'dep'");				rLinker.eval("colnames(data)[2] <- 'indep'");								rLinker.eval("print(data)");				rLinker.eval("depVar <- as.factor(data$dep)");				rLinker.eval("indepVar <- data$indep");				rLinker.eval("animal <- tree$tip.label");																rLinker.eval("traits <- data.frame(animal, depVar, indepVar)");				rLinker.eval("rownames(traits) <- animal");				rLinker.eval("fixed <- depVar ~ indepVar");				rLinker.eval("random <- ~ animal");				rLinker.eval("family <- \"categorical\"");   //CHANGE if types are different								rLinker.eval("Ainv <- inverseA(pedigree=tree, nodes=\"ALL\")$Ainv");												//From Kirsty: rLinker.eval("prior = <- list(B = list(mu = rep(0, 5), V = diag(5) * (1 + pi^2/3)), R = list(V = 1, n=1, fix=1), G = list(G1=list(V=1, n=1,alpha.mu=0, alpha.V=1000)))");				//In Hadfield's tutorial page 49 : list(R = list(V = 1, fix = 1), G = list(G1 = list(V = 1, nu = 0.002)))				//From Rafael 				rLinker.eval("prior <- list(R=list(V=1, fix=1), G=list(G1=list(V=1, nu=2.001)))");				rLinker.eval("prior <- list(R=list(V=1, fix=1), G=list(G1=list(V=1, nu=0.002)))");  //FROM RAFAEL; binary response     to rescale, R = list(V = 0.5, fix = 1)									//		rLinker.eval("prior = list(R = list(V = 1, nu = 0.002), B = list(mu = 0, V = 1e+08))");			//	rLinker.eval("prior = \"NULL\"");						//		rLinker.eval("prior = list(R = list(V = 1, fix = 1), G = list(G1 = list(V = 1e-10, nu = -1)))");		//		original REXP res = rLinker.eval("res <- MCMCglmm(fixed=fixed, random=random, family=family, data=traits, ginverse=list(animal=Ainv), nitt=100000, burnin=10000)");		// Rafael 				REXP res = rLinker.eval("res <- MCMCglmm(indepVar~depVar, random=~us(depVar):animal, rcov=~us(depVar):units, ginverse=list(animal=Ainv), prior=prior, data=traits, family=\"categorical\")");					REXP res = rLinker.eval("res <- MCMCglmm(ginverse=list(animal=Ainv), prior=prior, data=traits, family=family, fixed = fixed, pl=TRUE, random = random,  nitt=100000000, burnin=10000)");				//m1 <- MCMCglmm(resp~pred, random=~us(pred):species, rcov=~us(pred):units, ginverse=list(species=Ainv), prior=Prior, data=mydata, family="categorical")				Debugg.println("  res$Liab ==========");				//rLinker.eval("print(res$Liab)");				rLinker.eval("sL <- summary(res$Liab)");				rLinker.eval("print(sL)");				Debugg.println("  res$Liab ^==========");				if (res == null){					MesquiteMessage.println("MCMCglmm error: no results returned by MCMCglmm");					if (resultString != null)						resultString.setValue("MCMCglmm error: no results returned by MCMCglmm");					return;				}								//		REXP results = rLinker.eval("resultsSummary <- summary(res)");				REXP results = rLinker.eval("resultsSummary <- summary(res)");				rLinker.setRecordConsole(true);				rLinker.resetConsoleRecord();				rLinker.eval("print(resultsSummary)");				String consoleResults = rLinker.getConsoleRecord();				if (resultString != null)					resultString.setValue(consoleResults);				rLinker.setRecordConsole(false);				rLinker.resetConsoleRecord();								Debugg.println("result " + results.getClass() + "   " + results);				REXP solutions = rLinker.eval("resultsSummary$solutions");				Debugg.println("solutions " + solutions);				double[] solArray = ((double[])solutions.getContent());				Debugg.println(DoubleArray.toString(solArray));															/*	> str(summary(res))List of 10 $ DIC             : num 12.6 $ fixed.formula   :Class 'formula' length 3 Var1 ~ Var2  .. ..- attr(*, ".Environment")=<environment: R_GlobalEnv>  $ random.formula  :Class 'formula' length 2 ~animal  .. ..- attr(*, ".Environment")=<environment: R_GlobalEnv>  $ residual.formula:Class 'formula' length 2 ~units  .. ..- attr(*, ".Environment")=<environment: 0x1199af6e8>  $ solutions       : num [1:2, 1:5] 0.581 4.402 0.284 4.157 0.982 ...  ..- attr(*, "dimnames")=List of 2  .. ..$ : chr [1:2] "(Intercept)" "Var2"  .. ..$ : chr [1:5] "post.mean" "l-95% CI" "u-95% CI" "eff.samp" ... $ Gcovariances    : num [1, 1:4] 2.68e-02 2.40e-06 5.02e-02 1.84e+01  ..- attr(*, "dimnames")=List of 2  .. ..$ : chr "animal"  .. ..$ : chr [1:4] "post.mean" "l-95% CI" "u-95% CI" "eff.samp" $ Gterms          : int 1 $ Rcovariances    : num [1, 1:4] 6.67e-02 1.27e-10 3.58e-01 1.95e+01  ..- attr(*, "dimnames")=List of 2  .. ..$ : chr "units"  .. ..$ : chr [1:4] "post.mean" "l-95% CI" "u-95% CI" "eff.samp" $ cstats          : num [1:4] 1001 9991 10 900 $ cutpoints       : NULL - attr(*, "class")= chr [1:2] "summary.MCMCglmm" "list"					/*# convert the discrete variable to a factorVar1 <- as.factor(data$Discrete)Var2 <- data$Continuous# The variable animal holds the tip labels of the tree# For some odd reason the variable has to be labelled animalanimal <- tree$tip.label# Create a data frame with all the variables (after converting them to factors if need be). # If you had done this previously, you could just use your data frame as you read it in.# One column needs to be the tip labels (this seems redundant but it is how i got it to work)traits <- data.frame(animal, Var1, Var2)rownames(traits) <- animal# Create a fixed effects model (the distinction between fixed and random effect in the context of comparative methods and in a Bayesian MCMC framework is not that clear to me)fixed <- Var1 ~ Var2# Create a random effects model. This should at least include your phylogeny ("animal")random <- ~ animal# Since the dependent variable is categorical (same as binary for the purposes of this package)family <- "categorical"# Take the inverse of the phylogenetic variance-covariance matrix. This is actually technically not the inverse of the phy vcv matrix. It is actually a sparse matrix, as it includes empty values for all ancestoral nodes. For reasons detailed in Hadfield and Nakagawa 2010, this drastically increases the speed of the calculations (dont have to actually do the inversion) and memory requirements.Ainv <- inverseA(pedigree=tree, nodes="ALL")$Ainv# Assign priors for the R-matrix and G-matrix# I am just going to use the very diffuse prior that is the default.# Have not investigated the effect of the priors but this needs to be done.prior = "NULL"# Run MCMC chain ## Instead of inserting the phylogeny as the argument "pedigree" I find it useful just to put the inverted vcv matrix in the argument ginverse, which i believe is equivalentres <- MCMCglmm(fixed=fixed, random=random, family=family, data=traits, ginverse=list(animal=Ainv), nitt=10000, burnin=1000)# look at the summarysummary(res)# look at the plotsplot(res)	 */						}			else 	if (charStatesX instanceof CategoricalDistribution && charStatesY instanceof ContinuousDistribution){				Debugg.println("CATEGORICAL PREDICTOR, CONTINUOUS RESPONSE");				CategoricalDistribution indepX = (CategoricalDistribution)charStatesX;				ContinuousDistribution depY = (ContinuousDistribution)charStatesY;				int numTerminals = tree.numberOfTerminalsInClade(tree.getRoot());				double[] dependentValues = new double[numTerminals];				String[] rowNames = new String[numTerminals];				for (int i = 0; i< numTerminals; i++){					dependentValues[i] = depY.getState(apeTree.getMesquiteTaxon(i+1));					rowNames[i] = tree.getTaxa().getTaxonName(apeTree.getMesquiteTaxon(i+1));				}				int[] independentValues = new int[numTerminals];				for (int i = 0; i< numTerminals; i++){					independentValues[i] = CategoricalState.minimum(indepX.getState(apeTree.getMesquiteTaxon(i+1)));				}				rLinker.assign("data",dependentValues);				rLinker.eval("dim(data) <- c(" + numTerminals + ",1)");				rLinker.assign("rowNames",rowNames);				rLinker.eval("rownames(data) <- rowNames");				rLinker.eval("data <- as.data.frame(data)");  //turning into a data frame				rLinker.assign("secondColumn",independentValues);				rLinker.eval("data <- cbind(data, secondColumn)");				rLinker.eval("colnames(data)[1] <- 'dep'");				rLinker.eval("colnames(data)[2] <- 'indep'");								rLinker.eval("print(data)");				rLinker.eval("depVar <- as.factor(data$dep)");				rLinker.eval("indepVar <- data$indep");				rLinker.eval("animal <- tree$tip.label");																rLinker.eval("traits <- data.frame(animal, depVar, indepVar)");				rLinker.eval("rownames(traits) <- animal");				rLinker.eval("fixed <- depVar ~ indepVar");				rLinker.eval("random <- ~ animal");		//еее		rLinker.eval("family <- \"categorical\"");   //CHANGE if types are different				rLinker.eval("family <- \"gaussian\"");				rLinker.eval("Ainv <- inverseA(pedigree=tree, nodes=\"ALL\")$Ainv");												//From Kirsty: rLinker.eval("prior = <- list(B = list(mu = rep(0, 5), V = diag(5) * (1 + pi^2/3)), R = list(V = 1, n=1, fix=1), G = list(G1=list(V=1, n=1,alpha.mu=0, alpha.V=1000)))");				//In Hadfield's tutorial page 49 : list(R = list(V = 1, fix = 1), G = list(G1 = list(V = 1, nu = 0.002)))				//From Rafael 				rLinker.eval("prior <- list(R=list(V=1, fix=1), G=list(G1=list(V=1, nu=2.001)))");			//еее	rLinker.eval("prior <- list(R=list(V=1, fix=1), G=list(G1=list(V=1, nu=2.001)))");  //FROM RAFAEL; binary response     to rescale, R = list(V = 0.5, fix = 1)								rLinker.eval("prior=list(R=list(V=1,nu=0.002),G=list(G1=list(V=1,nu=0.002)))");					//		rLinker.eval("prior = list(R = list(V = 1, nu = 0.002), B = list(mu = 0, V = 1e+08))");			//	rLinker.eval("prior = \"NULL\"");						//		rLinker.eval("prior = list(R = list(V = 1, fix = 1), G = list(G1 = list(V = 1e-10, nu = -1)))");		//		original REXP res = rLinker.eval("res <- MCMCglmm(fixed=fixed, random=random, family=family, data=traits, ginverse=list(animal=Ainv), nitt=100000, burnin=10000)");		// Rafael 				REXP res = rLinker.eval("res <- MCMCglmm(indepVar~depVar, random=~us(depVar):animal, rcov=~us(depVar):units, ginverse=list(animal=Ainv), prior=prior, data=traits, family=\"categorical\")");					REXP res = rLinker.eval("res <- MCMCglmm(ginverse=list(animal=Ainv), prior=prior, data=traits, family=family, fixed = fixed, pl=TRUE, random = random,  nitt=10000000, burnin=10000)");				//m1 <- MCMCglmm(resp~pred, random=~us(pred):species, rcov=~us(pred):units, ginverse=list(species=Ainv), prior=Prior, data=mydata, family="categorical")				Debugg.println("  res$Liab ==========");				//rLinker.eval("print(res$Liab)");				rLinker.eval("sL <- summary(res$Liab)");				rLinker.eval("print(sL)");				Debugg.println("  res$Liab ^==========");				if (res == null){					MesquiteMessage.println("MCMCglmm error: no results returned by MCMCglmm");					if (resultString != null)						resultString.setValue("MCMCglmm error: no results returned by MCMCglmm");					return;				}								//		REXP results = rLinker.eval("resultsSummary <- summary(res)");				REXP results = rLinker.eval("resultsSummary <- summary(res)");				rLinker.setRecordConsole(true);				rLinker.resetConsoleRecord();				rLinker.eval("print(resultsSummary)");				String consoleResults = rLinker.getConsoleRecord();				if (resultString != null)					resultString.setValue(consoleResults);				rLinker.setRecordConsole(false);				rLinker.resetConsoleRecord();								Debugg.println("result " + results.getClass() + "   " + results);				REXP solutions = rLinker.eval("resultsSummary$solutions");				Debugg.println("solutions " + solutions);				double[] solArray = ((double[])solutions.getContent());				Debugg.println(DoubleArray.toString(solArray));									}		}		saveLastResult(result);		saveLastResultString(resultString);	}	/*.................................................................................................................*/	public String getParameters(){		return "MCMCglmm, reporting "; // + modeName.getValue();	}	/*.................................................................................................................*/	public String getName() {		return "MCMCglmm Correlation";	}	/*.................................................................................................................*/	/** Returns the name of the module in very short form.  For use for column headings and other constrained places.  Unless overridden returns getName()*/	public String getVeryShortName(){		return "glmm Correlation";	}	/*.................................................................................................................*/	public String getVersion() {		return "0.1";	}	/*.................................................................................................................*/	public boolean isPrerelease() {		return true;	}	/** marks the module as doing a substantive calculation - not decorative */	public boolean isSubstantive(){		return true;	}	/*.................................................................................................................*/	/** returns an explanation of what the module does.*/	public String getExplanation() {		return "Calls the R program MCMCglmm to assess association between two variables on a tree.  REPORTS AS...?." ;   //Debugg.println	}}